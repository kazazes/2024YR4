<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>2024 YR4 Orbit (Three.js)</title>
    <link rel="icon" href="data:," />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
      }
      canvas {
        display: block;
      }
      #info {
        position: absolute;
        top: 10px;
        width: 100%;
        color: white;
        text-align: center;
        font-family: Arial, sans-serif;
        pointer-events: none;
      }
      #risk-info {
        position: absolute;
        top: 40px;
        width: 100%;
        color: #ff4444;
        text-align: center;
        font-family: Arial, sans-serif;
        pointer-events: none;
        font-weight: bold;
        text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
      }
      .torino-3 {
        color: #ff4444;
        animation: pulse 2s infinite;
      }
      @keyframes pulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
        100% {
          opacity: 1;
        }
      }
      #controls {
        position: absolute;
        bottom: 10px;
        left: 10px;
        color: white;
        font-family: Arial, sans-serif;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <div id="info">Asteroid 2024 YR4 Orbit Visualization</div>
    <div id="risk-info"></div>
    <div id="controls">
      <label>
        <input type="checkbox" id="showOrbit" checked />
        Show Orbit
      </label>
      <br />
      <label>
        <input type="checkbox" id="animateAsteroid" checked />
        Animate Asteroid
      </label>
    </div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        1,
        1e10
      );
      camera.position.set(0, 2e8, 4e8);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Constants
      const AU = 1.495978707e8; // km
      const deg2rad = Math.PI / 180;
      const EARTH_RADIUS = 6371; // km

      // Create starfield
      const starGeometry = new THREE.BufferGeometry();
      const starVertices = [];
      for (let i = 0; i < 20000; i++) {
        const x = THREE.MathUtils.randFloatSpread(1e10);
        const y = THREE.MathUtils.randFloatSpread(1e10);
        const z = THREE.MathUtils.randFloatSpread(1e10);
        starVertices.push(x, y, z);
      }
      starGeometry.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(starVertices, 3)
      );
      const starMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 1e7,
      });
      const starField = new THREE.Points(starGeometry, starMaterial);
      scene.add(starField);

      // Add Sun
      const sunGeometry = new THREE.SphereGeometry(696340 * 2, 32, 32); // Sun radius in km (scaled up for visibility)
      const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
      scene.add(sunMesh);

      // Add Earth with texture
      const earthGeometry = new THREE.SphereGeometry(
        EARTH_RADIUS * 1000,
        32,
        32
      ); // Scaled up for visibility
      const earthMaterial = new THREE.MeshBasicMaterial({ color: 0x0077ff });
      const earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
      earthMesh.position.set(AU, 0, 0);
      scene.add(earthMesh);

      // Earth label
      const earthLabel = makeLabel("Earth");
      earthMesh.add(earthLabel);
      earthLabel.position.set(0, EARTH_RADIUS * 2000, 0);

      // Orbital Elements for 2024 YR4
      const a = 2.51647; // AU
      const e = 0.66162347;
      const inc = 3.40835; // deg
      const Omega = 271.36819; // deg
      const omega = 134.36408; // deg
      const M0 = 13.72139; // deg (Mean Anomaly at epoch)
      const a_km = a * AU;

      function orbitalPosition(f) {
        const r = (a_km * (1 - e * e)) / (1 + e * Math.cos(f));
        let x = r * Math.cos(f);
        let y = r * Math.sin(f);
        let z = 0;

        // Apply argument of periapsis rotation
        const cos_omega = Math.cos(omega * deg2rad);
        const sin_omega = Math.sin(omega * deg2rad);
        const x1 = x * cos_omega - y * sin_omega;
        const y1 = x * sin_omega + y * cos_omega;
        const z1 = z;

        // Apply inclination rotation
        const cos_inc = Math.cos(inc * deg2rad);
        const sin_inc = Math.sin(inc * deg2rad);
        const x2 = x1;
        const y2 = y1 * cos_inc - z1 * sin_inc;
        const z2 = y1 * sin_inc + z1 * cos_inc;

        // Apply longitude of ascending node rotation
        const cos_Omega = Math.cos(Omega * deg2rad);
        const sin_Omega = Math.sin(Omega * deg2rad);
        const X = x2 * cos_Omega - y2 * sin_Omega;
        const Y = x2 * sin_Omega + y2 * cos_Omega;
        const Z = z2;

        return new THREE.Vector3(X, Y, Z);
      }

      // Create orbit line
      const orbitPoints = [];
      for (let f_deg = 0; f_deg <= 360; f_deg += 1) {
        orbitPoints.push(orbitalPosition(f_deg * deg2rad));
      }

      const orbitGeometry = new THREE.BufferGeometry().setFromPoints(
        orbitPoints
      );
      const orbitMaterial = new THREE.LineBasicMaterial({
        color: 0xff6666,
        linewidth: 2,
      });
      const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
      scene.add(orbitLine);

      // Add asteroid
      const asteroidGeometry = new THREE.SphereGeometry(
        EARTH_RADIUS * 100,
        32,
        32
      ); // Much larger for visibility
      const asteroidMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        transparent: true,
        opacity: 0.9,
      });
      const asteroidMesh = new THREE.Mesh(asteroidGeometry, asteroidMaterial);
      // Add glow effect
      const asteroidGlow = new THREE.Sprite(
        new THREE.SpriteMaterial({
          map: new THREE.CanvasTexture(createGlowTexture()),
          color: 0xff4444,
          transparent: true,
          blending: THREE.AdditiveBlending,
        })
      );
      asteroidGlow.scale.set(EARTH_RADIUS * 300, EARTH_RADIUS * 300, 1);
      asteroidMesh.add(asteroidGlow);
      scene.add(asteroidMesh);

      // Asteroid label
      const asteroidLabel = makeLabel("2024 YR4");
      asteroidMesh.add(asteroidLabel);
      asteroidLabel.position.set(0, 100000, 0);

      function makeLabel(text) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        canvas.width = 256;
        canvas.height = 64;
        context.fillStyle = "white";
        context.font = "24px Arial";
        context.textAlign = "center";
        context.fillText(text, 128, 32);

        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(50000, 12500, 1);
        return sprite;
      }

      function createGlowTexture() {
        const canvas = document.createElement("canvas");
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext("2d");
        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, "rgba(255, 60, 60, 1)");
        gradient.addColorStop(0.3, "rgba(255, 60, 60, 0.5)");
        gradient.addColorStop(1, "rgba(255, 60, 60, 0)");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);
        return canvas;
      }

      // Animation variables
      let time = 0;
      const period = 10; // seconds for one orbit
      let currentImpactIndex = -1;
      let isSimulatingImpact = false;

      // UI Controls
      const showOrbitCheckbox = document.getElementById("showOrbit");
      const animateAsteroidCheckbox =
        document.getElementById("animateAsteroid");

      showOrbitCheckbox.addEventListener("change", (e) => {
        orbitLine.visible = e.target.checked;
      });

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      function animate() {
        requestAnimationFrame(animate);

        if (animateAsteroidCheckbox.checked) {
          time += 0.016; // Approximately 60fps

          if (isSimulatingImpact && currentImpactIndex >= 0) {
            // During impact simulation, move asteroid toward Earth
            const earthPos = earthMesh.position;
            const asteroidPos = asteroidMesh.position;
            const direction = new THREE.Vector3().subVectors(
              earthPos,
              asteroidPos
            );
            const distance = direction.length();

            if (distance > EARTH_RADIUS * 2) {
              // Move asteroid toward Earth
              direction.normalize();
              asteroidMesh.position.add(direction.multiplyScalar(AU * 0.01)); // Speed of approach

              // Make asteroid glow stronger as it approaches
              const intensity = 1 + (AU * 0.1 - distance) / (AU * 0.1);
              asteroidGlow.material.color.setRGB(intensity, 0.2, 0.2);
              asteroidGlow.scale.setScalar(EARTH_RADIUS * 300 * intensity);

              // Shake camera based on proximity
              if (distance < AU * 0.05) {
                const shake = (1 - distance / (AU * 0.05)) * 1000000;
                camera.position.x += (Math.random() - 0.5) * shake;
                camera.position.y += (Math.random() - 0.5) * shake;
                camera.position.z += (Math.random() - 0.5) * shake;
              }
            } else {
              // Impact occurred
              isSimulatingImpact = false;
              currentImpactIndex = -1;
              impactSelect.value = -1;

              // Reset asteroid position
              time = 0;
              const f = 0;
              const pos = orbitalPosition(f);
              asteroidMesh.position.copy(pos);

              // Reset glow effect
              asteroidGlow.material.color.setRGB(1, 0.2, 0.2);
              asteroidGlow.scale.setScalar(EARTH_RADIUS * 300);
            }
          } else {
            // Normal orbital motion
            const f = ((time % period) / period) * 2 * Math.PI;
            const pos = orbitalPosition(f);
            asteroidMesh.position.copy(pos);
          }
        }

        controls.update();
        renderer.render(scene, camera);
      }

      animate();

      // Load ephemeris data and initialize impact-related features
      const response = await fetch("ephemeris.json");
      const ephemeris = await response.json();

      // Create impact markers
      const impactMarkers = [];
      const impactDates = ephemeris.impact_risk.potential_impacts.dates;
      const impactProbs = ephemeris.impact_risk.potential_impacts.probabilities;

      for (let i = 0; i < impactDates.length; i++) {
        const markerGeometry = new THREE.SphereGeometry(
          EARTH_RADIUS * 500,
          16,
          16
        );
        const markerMaterial = new THREE.MeshBasicMaterial({
          color: 0xff0000,
          transparent: true,
          opacity: 0.3,
          blending: THREE.AdditiveBlending,
        });
        const marker = new THREE.Mesh(markerGeometry, markerMaterial);
        marker.position.copy(earthMesh.position);
        marker.visible = false;
        scene.add(marker);
        impactMarkers.push(marker);
      }

      // Add impact simulation controls
      const controlsDiv = document.getElementById("controls");
      controlsDiv.innerHTML += `
        <br/>
        <label>Impact Simulation:</label>
        <br/>
        <select id="impactSelect">
          <option value="-1">Select impact date...</option>
          ${impactDates
            .map(
              (date, i) =>
                `<option value="${i}">${date} (Prob: ${impactProbs[
                  i
                ].toExponential(1)})</option>`
            )
            .join("")}
        </select>
        <br/>
        <button id="simulateImpact">Simulate Impact</button>
      `;

      const impactSelect = document.getElementById("impactSelect");
      const simulateButton = document.getElementById("simulateImpact");

      simulateButton.addEventListener("click", () => {
        const selectedIndex = parseInt(impactSelect.value);
        if (selectedIndex >= 0) {
          currentImpactIndex = selectedIndex;
          isSimulatingImpact = true;

          // Store current camera position for reset
          const originalCameraPos = camera.position.clone();

          // Move camera closer to Earth
          const earthPos = earthMesh.position;
          camera.position.set(
            earthPos.x + EARTH_RADIUS * 100,
            earthPos.y + EARTH_RADIUS * 100,
            earthPos.z + EARTH_RADIUS * 100
          );

          // Look at Earth
          controls.target.copy(earthPos);

          // Hide all markers except the selected one
          impactMarkers.forEach((marker, i) => {
            marker.visible = i === selectedIndex;
          });

          // Reset after simulation
          setTimeout(() => {
            camera.position.copy(originalCameraPos);
            controls.target.set(0, 0, 0);
          }, 10000); // Reset after 10 seconds
        }
      });

      // Display risk information
      const riskInfo = document.getElementById("risk-info");
      const torinoScale = ephemeris.impact_risk.torino_scale.maximum;
      const impactVelocity = ephemeris.impact_risk.impact_velocity;
      const potentialImpacts = ephemeris.impact_risk.potential_impacts;
      const lastUpdated = ephemeris.impact_risk.last_updated;

      riskInfo.innerHTML = `
        <span class="torino-3">
          ⚠️ Impact Risk Assessment: Torino Scale ${torinoScale} ⚠️
          <br>
          <span style="font-size: 0.9em">
            Requires attention from astronomers - Potential for regional damage
            <br>
            Impact Velocity: ${impactVelocity.value.toFixed(2)} ${
        impactVelocity.unit
      }
            <br>
            Potential Impacts: ${potentialImpacts.count} detected
            <br>
            <span style="font-size: 0.8em; opacity: 0.8;">
              Last Updated: ${lastUpdated || "Not available"}
            </span>
          </span>
        </span>
      `;
    </script>
  </body>
</html>
