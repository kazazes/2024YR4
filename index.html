<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>2024 YR4 Orbit (Three.js)</title>
    <link rel="icon" href="data:," />
    <!-- Retro digital font -->
    <link
      href="https://fonts.googleapis.com/css2?family=VT323&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        font-family: "VT323", monospace;
      }
      canvas {
        display: block;
      }

      /* Scanline effect */
      body::after {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: repeating-linear-gradient(
          0deg,
          rgba(0, 0, 0, 0.05) 0px,
          rgba(0, 0, 0, 0.05) 1px,
          transparent 1px,
          transparent 4px
        );
        pointer-events: none;
        animation: scanlines 20s infinite linear;
        opacity: 0.3;
      }
      @keyframes scanlines {
        from {
          background-position: 0 0;
        }
        to {
          background-position: 0 100%;
        }
      }

      /* CRT screen effect */
      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
          circle at center,
          transparent 0%,
          rgba(0, 0, 0, 0.2) 90%,
          rgba(0, 0, 0, 0.4) 100%
        );
        pointer-events: none;
      }

      #info {
        position: absolute;
        top: 20px;
        width: 100%;
        color: #0f0;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 2px;
        text-shadow: 0 0 10px #0f0;
        animation: flicker 5s infinite;
      }
      @keyframes flicker {
        0% {
          opacity: 1;
        }
        49% {
          opacity: 1;
        }
        50% {
          opacity: 0.8;
        }
        51% {
          opacity: 1;
        }
        59% {
          opacity: 1;
        }
        60% {
          opacity: 0.8;
        }
        61% {
          opacity: 1;
        }
      }

      #risk-info {
        position: absolute;
        top: 80px;
        width: 100%;
        color: #f00;
        text-align: center;
        font-weight: bold;
        text-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
        background: rgba(20, 0, 0, 0.5);
        padding: 20px 0;
        border-top: 1px solid rgba(255, 0, 0, 0.3);
        border-bottom: 1px solid rgba(255, 0, 0, 0.3);
      }
      .torino-3 {
        color: #f00;
        animation: warning-pulse 1.5s infinite;
      }
      @keyframes warning-pulse {
        0% {
          text-shadow: 0 0 10px #f00;
        }
        50% {
          text-shadow: 0 0 20px #f00, 0 0 40px #f00;
        }
        100% {
          text-shadow: 0 0 10px #f00;
        }
      }

      /* Flexbox controls panel */
      #controls {
        position: absolute;
        bottom: 20px;
        left: 20px;
        color: #0f0;
        background: rgba(0, 20, 0, 0.8);
        padding: 20px;
        border: 1px solid #0f0;
        box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
        text-transform: uppercase;
        letter-spacing: 1px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      #controls label {
        display: flex;
        align-items: center;
        margin: 5px 0;
        cursor: pointer;
      }
      /* Custom checkbox toggle */
      #controls input[type="checkbox"] {
        appearance: none;
        width: 20px;
        height: 20px;
        border: 2px solid #0f0;
        background: transparent;
        margin-right: 8px;
        position: relative;
        cursor: pointer;
      }
      #controls input[type="checkbox"]:checked::before {
        content: "";
        position: absolute;
        width: 100%;
        height: 100%;
        background: #0f0;
        opacity: 0.5;
        top: 0;
        left: 0;
        border-radius: 50%;
      }
      #impactSelect {
        background: rgba(0, 20, 0, 0.8);
        color: #0f0;
        border: 1px solid #0f0;
        padding: 5px;
        margin: 10px 0;
        width: 100%;
        cursor: pointer;
      }
      #simulateImpact {
        background: #f00;
        color: white;
        border: none;
        padding: 10px 20px;
        margin-top: 10px;
        cursor: pointer;
        text-transform: uppercase;
        font-weight: bold;
        letter-spacing: 2px;
        animation: button-pulse 2s infinite;
        width: 100%;
      }
      @keyframes button-pulse {
        0% {
          background-color: #f00;
          box-shadow: 0 0 10px #f00;
        }
        50% {
          background-color: #d00;
          box-shadow: 0 0 20px #f00;
        }
        100% {
          background-color: #f00;
          box-shadow: 0 0 10px #f00;
        }
      }

      /* Warning overlay using opacity transitions */
      .warning-overlay {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #f00;
        font-size: 24px;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 3px;
        pointer-events: none;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
      }
      .warning-overlay.active {
        opacity: 1;
      }

      /* Console UI styling */
      #console {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80%;
        max-width: 800px;
        height: 60%;
        background: rgba(0, 20, 0, 0.9);
        border: 2px solid #0f0;
        box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        color: #0f0;
        font-family: "VT323", monospace;
        padding: 20px;
        display: none;
        z-index: 1000;
        overflow: hidden;
        animation: console-glow 2s infinite;
      }
      @keyframes console-glow {
        0% {
          box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }
        50% {
          box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
        }
        100% {
          box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }
      }
      #console-header {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        background: #0f0;
        color: #000;
        padding: 5px 10px;
        font-weight: bold;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      #console-close {
        cursor: pointer;
        background: none;
        border: none;
        color: #000;
        font-weight: bold;
        font-size: 20px;
      }
      #console-content {
        height: calc(100% - 30px);
        margin-top: 30px;
        overflow-y: auto;
        padding: 10px;
        font-size: 14px;
        line-height: 1.4;
      }
      #console-content::-webkit-scrollbar {
        width: 8px;
      }
      #console-content::-webkit-scrollbar-track {
        background: rgba(0, 20, 0, 0.5);
      }
      #console-content::-webkit-scrollbar-thumb {
        background: #0f0;
      }
      .console-line {
        margin: 2px 0;
        opacity: 0;
        animation: type-in 0.1s forwards;
      }
      @keyframes type-in {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }
      .console-error {
        color: #f00;
      }
      .console-warning {
        color: #ff0;
      }
      .console-success {
        color: #0f0;
      }
      #fetch-data {
        background: rgba(0, 20, 0, 0.8);
        color: #0f0;
        border: 1px solid #0f0;
        padding: 5px 10px;
        cursor: pointer;
        text-transform: uppercase;
        font-family: "VT323", monospace;
        margin-top: 10px;
        animation: button-glow 2s infinite;
      }
      @keyframes button-glow {
        0% {
          box-shadow: 0 0 5px #0f0;
        }
        50% {
          box-shadow: 0 0 15px #0f0;
        }
        100% {
          box-shadow: 0 0 5px #0f0;
        }
      }

      /* Progress bar for simulation */
      #impactProgress {
        display: none;
        width: 100%;
        margin-top: 10px;
        appearance: none;
        height: 10px;
      }
      #impactProgress::-webkit-progress-bar {
        background-color: #222;
        border-radius: 5px;
      }
      #impactProgress::-webkit-progress-value {
        background-color: #0f0;
        border-radius: 5px;
      }

      /* Glitch effect for risk info */
      @keyframes glitch {
        0% {
          text-shadow: 2px 2px 0 #f00;
        }
        50% {
          text-shadow: -2px -2px 0 #0ff;
        }
        100% {
          text-shadow: 2px 2px 0 #f00;
        }
      }
      .glitch {
        animation: glitch 0.5s infinite;
      }

      /* Tooltip style */
      .tooltip {
        position: relative;
        cursor: help;
      }
      .tooltip::after {
        content: attr(data-tip);
        position: absolute;
        bottom: 125%;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: #0f0;
        padding: 4px 8px;
        white-space: nowrap;
        opacity: 0;
        transition: opacity 0.3s;
        pointer-events: none;
        border-radius: 4px;
        font-size: 0.8em;
      }
      .tooltip:hover::after {
        opacity: 1;
      }
    </style>
  </head>
  <body>
    <div id="info">
      ⚠ Weyland-Yutani Corporation ⚠<br />Asteroid Threat Assessment System
    </div>
    <div id="risk-info">
      <!-- Risk info will be injected here -->
    </div>
    <div id="controls">
      <div style="color: #0f0; margin-bottom: 15px; font-size: 0.9em">
        SYSTEM STATUS: ONLINE
      </div>
      <label>
        <input type="checkbox" id="showOrbit" checked />
        Orbital Path Display
      </label>
      <label>
        <input type="checkbox" id="animateAsteroid" checked />
        Real-time Tracking
      </label>
      <!-- Impact Simulation controls -->
      <label>Impact Simulation:</label>
      <select id="impactSelect">
        <option value="-1">Select impact date...</option>
      </select>
      <button id="simulateImpact">Simulate Impact</button>
      <progress id="impactProgress" max="100" value="0"></progress>
      <button id="fetch-data">UPDATE ORBITAL DATA</button>
    </div>
    <div class="warning-overlay" id="warningOverlay">
      ⚠ IMPACT SIMULATION IN PROGRESS ⚠<br />
      STAND BY FOR ANALYSIS
    </div>
    <div id="console">
      <div id="console-header">
        <span>WEYLAND-YUTANI ORBITAL DATABASE ACCESS</span>
        <button id="console-close">×</button>
      </div>
      <div id="console-content"></div>
    </div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        1,
        1e10
      );
      camera.position.set(0, 2e8, 4e8);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Constants
      const AU = 1.495978707e8; // km
      const deg2rad = Math.PI / 180;
      const EARTH_RADIUS = 6371; // km

      // Create starfield
      const starGeometry = new THREE.BufferGeometry();
      const starVertices = [];
      const STAR_RADIUS = 1e10;
      const STAR_COUNT = 20000;
      for (let i = 0; i < STAR_COUNT; i++) {
        const theta = 2 * Math.PI * Math.random();
        const phi = Math.acos(2 * Math.random() - 1);
        const x = STAR_RADIUS * Math.sin(phi) * Math.cos(theta);
        const y = STAR_RADIUS * Math.sin(phi) * Math.sin(theta);
        const z = STAR_RADIUS * Math.cos(phi);
        starVertices.push(x, y, z);
      }
      starGeometry.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(starVertices, 3)
      );
      const starMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 3,
        sizeAttenuation: false,
        opacity: 0.8,
        transparent: true,
      });
      const starField = new THREE.Points(starGeometry, starMaterial);
      scene.add(starField);

      // Add Sun
      const sunGeometry = new THREE.SphereGeometry(696340 * 2, 32, 32);
      const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
      scene.add(sunMesh);

      // Add Earth
      const earthGeometry = new THREE.SphereGeometry(
        EARTH_RADIUS * 1000,
        32,
        32
      );
      const earthMaterial = new THREE.MeshBasicMaterial({ color: 0x0077ff });
      const earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
      earthMesh.position.set(AU, 0, 0);
      scene.add(earthMesh);

      // Earth label
      const earthLabel = makeLabel("Earth");
      earthMesh.add(earthLabel);
      earthLabel.position.set(0, EARTH_RADIUS * 2000, 0);

      // Orbital Elements for 2024 YR4
      const a = 2.51647; // AU
      const e = 0.66162347;
      const inc = 3.40835; // deg
      const Omega = 271.36819; // deg
      const omega = 134.36408; // deg
      const M0 = 13.72139; // deg
      const a_km = a * AU;

      function orbitalPosition(f) {
        const r = (a_km * (1 - e * e)) / (1 + e * Math.cos(f));
        let x = r * Math.cos(f);
        let y = r * Math.sin(f);
        let z = 0;
        const cos_omega = Math.cos(omega * deg2rad);
        const sin_omega = Math.sin(omega * deg2rad);
        const x1 = x * cos_omega - y * sin_omega;
        const y1 = x * sin_omega + y * cos_omega;
        const z1 = z;
        const cos_inc = Math.cos(inc * deg2rad);
        const sin_inc = Math.sin(inc * deg2rad);
        const x2 = x1;
        const y2 = y1 * cos_inc - z1 * sin_inc;
        const z2 = y1 * sin_inc + z1 * cos_inc;
        const cos_Omega = Math.cos(Omega * deg2rad);
        const sin_Omega = Math.sin(Omega * deg2rad);
        const X = x2 * cos_Omega - y2 * sin_Omega;
        const Y = x2 * sin_Omega + y2 * cos_Omega;
        const Z = z2;
        return new THREE.Vector3(X, Y, Z);
      }

      // Create orbit line
      const orbitPoints = [];
      for (let f_deg = 0; f_deg <= 360; f_deg += 1) {
        orbitPoints.push(orbitalPosition(f_deg * deg2rad));
      }
      const orbitGeometry = new THREE.BufferGeometry().setFromPoints(
        orbitPoints
      );
      const orbitMaterial = new THREE.LineBasicMaterial({
        color: 0xff6666,
        linewidth: 2,
      });
      const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
      scene.add(orbitLine);

      // Add asteroid
      const asteroidGeometry = new THREE.SphereGeometry(
        EARTH_RADIUS * 100,
        32,
        32
      );
      const asteroidMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        transparent: true,
        opacity: 0.9,
      });
      const asteroidMesh = new THREE.Mesh(asteroidGeometry, asteroidMaterial);
      const asteroidGlow = new THREE.Sprite(
        new THREE.SpriteMaterial({
          map: new THREE.CanvasTexture(createGlowTexture()),
          color: 0xff4444,
          transparent: true,
          blending: THREE.AdditiveBlending,
        })
      );
      asteroidGlow.scale.set(EARTH_RADIUS * 300, EARTH_RADIUS * 300, 1);
      asteroidMesh.add(asteroidGlow);
      scene.add(asteroidMesh);

      // Asteroid label
      const asteroidLabel = makeLabel("2024 YR4");
      asteroidMesh.add(asteroidLabel);
      asteroidLabel.position.set(0, 100000, 0);

      function makeLabel(text) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        canvas.width = 256;
        canvas.height = 64;
        context.fillStyle = "white";
        context.font = "24px VT323";
        context.textAlign = "center";
        context.fillText(text, 128, 32);
        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(50000, 12500, 1);
        return sprite;
      }

      function createGlowTexture() {
        const canvas = document.createElement("canvas");
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext("2d");
        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, "rgba(255, 60, 60, 1)");
        gradient.addColorStop(0.3, "rgba(255, 60, 60, 0.5)");
        gradient.addColorStop(1, "rgba(255, 60, 60, 0)");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);
        return canvas;
      }

      let time = 0;
      const period = 10; // seconds for one orbit
      let currentImpactIndex = -1;
      let isSimulatingImpact = false;
      let simulationInterval, progressInterval;

      const showOrbitCheckbox = document.getElementById("showOrbit");
      const animateAsteroidCheckbox =
        document.getElementById("animateAsteroid");
      showOrbitCheckbox.addEventListener("change", (e) => {
        orbitLine.visible = e.target.checked;
      });
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      function animate() {
        requestAnimationFrame(animate);
        if (animateAsteroidCheckbox.checked) {
          time += 0.016;
          if (isSimulatingImpact && currentImpactIndex >= 0) {
            const earthPos = earthMesh.position;
            const asteroidPos = asteroidMesh.position;
            const direction = new THREE.Vector3().subVectors(
              earthPos,
              asteroidPos
            );
            const distance = direction.length();
            if (distance > EARTH_RADIUS * 2) {
              direction.normalize();
              asteroidMesh.position.add(direction.multiplyScalar(AU * 0.01));
              const intensity = 1 + (AU * 0.1 - distance) / (AU * 0.1);
              asteroidGlow.material.color.setRGB(intensity, 0.2, 0.2);
              asteroidGlow.scale.setScalar(EARTH_RADIUS * 300 * intensity);
              if (distance < AU * 0.05) {
                const shake = (1 - distance / (AU * 0.05)) * 1000000;
                camera.position.x += (Math.random() - 0.5) * shake;
                camera.position.y += (Math.random() - 0.5) * shake;
                camera.position.z += (Math.random() - 0.5) * shake;
              }
            } else {
              isSimulatingImpact = false;
              currentImpactIndex = -1;
              document.getElementById("impactSelect").value = -1;
              time = 0;
              const pos = orbitalPosition(0);
              asteroidMesh.position.copy(pos);
              asteroidGlow.material.color.setRGB(1, 0.2, 0.2);
              asteroidGlow.scale.setScalar(EARTH_RADIUS * 300);
              clearInterval(simulationInterval);
              clearInterval(progressInterval);
              document.getElementById("impactProgress").style.display = "none";
              document.getElementById("impactProgress").value = 0;
              document.getElementById("risk-info").classList.remove("glitch");
              document
                .getElementById("warningOverlay")
                .classList.remove("active");
            }
          } else {
            const f = ((time % period) / period) * 2 * Math.PI;
            const pos = orbitalPosition(f);
            asteroidMesh.position.copy(pos);
          }
        }
        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      async function loadEphemeris() {
        const response = await fetch("ephemeris.json");
        return response.json();
      }
      const ephemeris = await loadEphemeris();

      // Create impact markers
      const impactMarkers = [];
      const impactDates = ephemeris.impact_risk.potential_impacts.dates || [];
      const impactProbs =
        ephemeris.impact_risk.potential_impacts.probabilities || [];
      for (let i = 0; i < impactDates.length; i++) {
        const markerGeometry = new THREE.SphereGeometry(
          EARTH_RADIUS * 500,
          16,
          16
        );
        const markerMaterial = new THREE.MeshBasicMaterial({
          color: 0xff0000,
          transparent: true,
          opacity: 0.3,
          blending: THREE.AdditiveBlending,
        });
        const marker = new THREE.Mesh(markerGeometry, markerMaterial);
        marker.position.copy(earthMesh.position);
        marker.visible = false;
        scene.add(marker);
        impactMarkers.push(marker);
      }
      // Populate impact select options
      const impactSelect = document.getElementById("impactSelect");
      impactSelect.innerHTML =
        `<option value="-1">Select impact date...</option>` +
        impactDates
          .map(
            (date, i) =>
              `<option value="${i}">${date} (Prob: ${impactProbs[
                i
              ].toExponential(1)})</option>`
          )
          .join("");

      const simulateButton = document.getElementById("simulateImpact");
      simulateButton.addEventListener("click", () => {
        const selectedIndex = parseInt(impactSelect.value);
        if (selectedIndex >= 0) {
          currentImpactIndex = selectedIndex;
          isSimulatingImpact = true;
          document.getElementById("risk-info").classList.add("glitch");
          const warningOverlay = document.getElementById("warningOverlay");
          warningOverlay.classList.add("active");
          const progressBar = document.getElementById("impactProgress");
          progressBar.style.display = "block";
          progressBar.value = 0;
          let progress = 0;
          progressInterval = setInterval(() => {
            progress += 1;
            progressBar.value = progress;
            if (progress >= 100) clearInterval(progressInterval);
          }, 100);
          const originalCameraPos = camera.position.clone();
          const earthPos = earthMesh.position;
          camera.position.set(
            earthPos.x + EARTH_RADIUS * 100,
            earthPos.y + EARTH_RADIUS * 100,
            earthPos.z + EARTH_RADIUS * 100
          );
          controls.target.copy(earthPos);
          impactMarkers.forEach((marker, i) => {
            marker.visible = i === selectedIndex;
          });
          simulationInterval = setTimeout(() => {
            camera.position.copy(originalCameraPos);
            controls.target.set(0, 0, 0);
            // Simulation end is handled in the animate loop.
          }, 10000);
        }
      });

      // Update risk information display
      const riskInfo = document.getElementById("risk-info");
      const torinoScale = ephemeris.impact_risk.torino_scale.maximum;
      const impactVelocity = ephemeris.impact_risk.impact_velocity;
      const potentialImpacts = ephemeris.impact_risk.potential_impacts;
      const lastUpdated = ephemeris.impact_risk.last_updated;
      riskInfo.innerHTML = `
        <span class="torino-3">
          ⚠ THREAT ASSESSMENT: TORINO SCALE ${torinoScale} ⚠<br>
          <span style="font-size: 0.9em">
            ALERT: IMMEDIATE ASTRONOMICAL OBSERVATION REQUIRED<br>
            IMPACT VELOCITY: ${impactVelocity.value.toFixed(2)} ${
        impactVelocity.unit
      }<br>
            DETECTED IMPACT SCENARIOS: ${potentialImpacts.count}<br>
            <span style="font-size: 0.8em; opacity: 0.8;">
              LAST SYSTEM UPDATE: ${lastUpdated || "DATA UNAVAILABLE"}
            </span>
          </span>
        </span>
      `;

      // Console UI functionality
      const consoleUI = {
        element: document.getElementById("console"),
        content: document.getElementById("console-content"),
        isVisible: false,
        show() {
          this.element.style.display = "block";
          this.isVisible = true;
        },
        hide() {
          this.element.style.display = "none";
          this.isVisible = false;
        },
        async addLine(text, type = "") {
          const line = document.createElement("div");
          line.className = `console-line ${type}`;
          line.textContent = text;
          this.content.appendChild(line);
          this.content.scrollTop = this.content.scrollHeight;
          await new Promise((resolve) => setTimeout(resolve, 50));
        },
        clear() {
          this.content.innerHTML = "";
        },
      };
      document.getElementById("console-close").addEventListener("click", () => {
        consoleUI.hide();
      });
      document
        .getElementById("fetch-data")
        .addEventListener("click", async () => {
          consoleUI.show();
          consoleUI.clear();
          await consoleUI.addLine("INITIALIZING THREAT ASSESSMENT UPDATE...");
          await consoleUI.addLine(
            "ACCESSING JPL SENTRY SYSTEM...",
            "console-warning"
          );
          try {
            await consoleUI.addLine("> CONNECTING TO ssd-api.jpl.nasa.gov");
            const sentryUrl = "https://ssd-api.jpl.nasa.gov/sentry.api";
            const params = new URLSearchParams({
              des: "2024 YR4",
              format: "json",
            });
            await consoleUI.addLine("ESTABLISHING SECURE CONNECTION...");
            const response = await fetch(`${sentryUrl}?${params}`);
            if (!response.ok)
              throw new Error(`API responded with status: ${response.status}`);
            const data = await response.json();
            await consoleUI.addLine(
              "CONNECTION ESTABLISHED",
              "console-success"
            );
            if (data && data.count > 0) {
              await consoleUI.addLine("ANALYZING IMPACT SCENARIOS...");
              const summary = data.summary;
              await consoleUI.addLine(
                `DETECTED IMPACT SCENARIOS: ${summary.n_imp}`,
                "console-warning"
              );
              await consoleUI.addLine(
                `MAXIMUM TORINO SCALE: ${summary.ts_max}`,
                summary.ts_max > 0 ? "console-error" : "console-success"
              );
              await consoleUI.addLine(
                `CUMULATIVE IMPACT PROBABILITY: ${summary.ip_cum}`,
                "console-warning"
              );
              await consoleUI.addLine("UPDATING LOCAL DATABASE...");
              await consoleUI.addLine("DATA SYNCHRONIZED", "console-success");
              riskInfo.innerHTML = `
              <span class="torino-3">
                ⚠ THREAT ASSESSMENT: TORINO SCALE ${summary.ts_max} ⚠<br>
                <span style="font-size: 0.9em">
                  ALERT: IMMEDIATE ASTRONOMICAL OBSERVATION REQUIRED<br>
                  IMPACT VELOCITY: ${parseFloat(
                    data.data[0].v_inf || 0
                  ).toFixed(2)} km/s<br>
                  DETECTED IMPACT SCENARIOS: ${summary.n_imp}<br>
                  <span style="font-size: 0.8em; opacity: 0.8;">
                    LAST SYSTEM UPDATE: ${summary.cdate || "DATA UNAVAILABLE"}
                  </span>
                </span>
              </span>
            `;
              impactSelect.innerHTML =
                `<option value="-1">Select impact date...</option>` +
                data.data
                  .map(
                    (impact, i) =>
                      `<option value="${i}">${impact.date} (Prob: ${parseFloat(
                        impact.ip
                      ).toExponential(1)})</option>`
                  )
                  .join("");
            } else {
              await consoleUI.addLine(
                "NO IMPACT SCENARIOS DETECTED",
                "console-warning"
              );
            }
            await consoleUI.addLine("UPDATE COMPLETE", "console-success");
            setTimeout(() => {
              consoleUI.hide();
            }, 5000);
          } catch (error) {
            await consoleUI.addLine("ERROR: " + error.message, "console-error");
            await consoleUI.addLine(
              "CONNECTION FAILED - RETRY RECOMMENDED",
              "console-error"
            );
            setTimeout(() => {
              consoleUI.hide();
            }, 4000);
          }
        });
    </script>
  </body>
</html>
